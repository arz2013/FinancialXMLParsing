/* adder.jj Adding up numbers */
options {
	STATIC = false;
	LOOKAHEAD = 3;
}

PARSER_BEGIN(QueryParser)

package edu.ucsd;

import edu.ucsd.grammar.ForClause;

	public class QueryParser {
		public static void main(String[] args) 
		throws ParseException, TokenMgrError {
			QueryParser queryParser = new QueryParser( System.in );
			queryParser.parse(); }
	}


	class VariableDeclaration implements ForClause {
		private String variableName;
		private String variableType;

		public VariableDeclaration(String variableName, String variableType) {
			this.variableName = variableName;
			this.variableType = variableType;
		}

		public String getVariableName() {
			return this.variableName;
		}

		public String getVariableType() {
			return this.variableType;
		}	
	}

	class VariableAssignment implements ForClause {
		private String variableName;
		private String variableXpressionAssignment;
		
		public VariableAssignment(String variableName, String variableXpressionAssignment) {
			this.variableName = variableName;
			this.variableXpressionAssignment = variableXpressionAssignment;
		}

		public String getVariableName() {
			return this.variableName;
		}

		public String getVariableXpressionAssignment() {
			return this.variableXpressionAssignment;
		}
			
	}

PARSER_END(QueryParser)

/* Lexical Analyzer */
SKIP : { " " }
SKIP : { "\n" | "\r" | "\r\n" }

TOKEN : { < KWFOR : "for" > }
TOKEN : { < KWWHERE : "where" > }
TOKEN : { < KWRETURN : "return" > }
TOKEN : { < #LETTER : ["a"-"z", "A"-"Z"] > } 
TOKEN : { < #DIGIT : (["0"-"9"])+ > }
TOKEN : { < WORD : "'"(["a"-"z", "A"-"Z", "0"-"9", "_"])+"'" > }
/* The Identifier Types have to appear before the more generic Identifier
   otherwise it will match Identifier first before Identifier Types 
   so more specific ones have to appear first */
TOKEN : { < DOC_AND_SENTENCE_FUNCTION : "."("contains") > }
TOKEN : { < FUNCTION : ("shortest_term_starting_with" | "longest_term_containing")  > }
TOKEN : { < WHERE_CLAUSE_CONNECTOR : ( "or" | "and" ) > }
TOKEN : { < NOT : "not" > }
TOKEN : { < IDENTIFIER_TYPES : ("Word" | "Sentence" | "Document") > }
TOKEN : { < IDENTIFIER : (<LETTER> | "_") (<LETTER> | <DIGIT> | "_")* > }
TOKEN : { < IDENTIFIER_TYPE_SEPARATOR : ":" > }
TOKEN : { < VARIABLE_ASSIGNMENT : "=" > }
TOKEN : { < OPEN_PAR : "(" > }
TOKEN : { < CLOSE_PAR : ")" > }
TOKEN : { < CLAUSE_SEPARATOR : "," > }
/* TOKEN : { < VAR_TYPE_DECLARATION : (<IDENTIFIER> ":" ("Word" | "Sentence" | "Document" > ) } */

/* Parser */
void parse() :
{
}
{
	FOR_CLAUSE()
	WHERE_CLAUSE()
	RETURN_CLAUSE()
	<EOF>
}

void FOR_CLAUSE() :
{
}
{
	<KWFOR>
	/* The "(" and ")" are necessary otherwise early exit */
	(IDENTIFIER_TYPE_DECLARATION() | VARIABLE_ASSIGNMENT())
	( 
		<CLAUSE_SEPARATOR>
		(IDENTIFIER_TYPE_DECLARATION() | VARIABLE_ASSIGNMENT())
	)*
}

void WHERE_CLAUSE() :
{
}
{
	<KWWHERE>
	(WORD_CONSTRAINT() | CONTAINS_CONSTRAINT())
	(<WHERE_CLAUSE_CONNECTOR>
	 (WORD_CONSTRAINT() | CONTAINS_CONSTRAINT())
	)*
}

void RETURN_CLAUSE() :
{
	Token t;
}
{
	<KWRETURN>
	(t = <IDENTIFIER>)
	{ System.out.println(t.image); }
}

void IDENTIFIER_TYPE_DECLARATION() :
{
	Token t;
}
{	
	(t = <IDENTIFIER>)
	{ System.out.println(t.image); }
	<IDENTIFIER_TYPE_SEPARATOR>
	(t = <IDENTIFIER_TYPES>)
	{ System.out.println(t.image); } 
}

void VARIABLE_ASSIGNMENT() :
{
	Token t;
}
{
	(t = <IDENTIFIER>)
	{ System.out.println(t.image); }
	<VARIABLE_ASSIGNMENT>
	(t = <FUNCTION>)
	{ System.out.println(t.image); }
	<OPEN_PAR>
	(t = <IDENTIFIER>)
        { System.out.println(t.image); }
	<CLOSE_PAR>
}

void WORD_CONSTRAINT() : 
{
	Token t;
}
{
	(t = <IDENTIFIER>)
	{System.out.println(t.image);}
	<VARIABLE_ASSIGNMENT>
	(t = <WORD>)
	{System.out.println(t.image);} 
}

void CONTAINS_CONSTRAINT() :
{
	Token t;
}
{
	(t = <IDENTIFIER>)
	{System.out.println(t.image);}
	<DOC_AND_SENTENCE_FUNCTION>
	<OPEN_PAR>
	(t = <IDENTIFIER>)
	{System.out.println(t.image);}
	<CLOSE_PAR>
}

